# Code Review - 2026-02-07 01:05:00

## Resume

Integration de l'endpoint `/api/contact-links` dans le frontend Nuxt 4. Le composable `useContactLinks` est cree pour fetcher les donnees depuis le backend, et `useSocialData` est refactorise pour l'utiliser avec un mecanisme de fallback vers des donnees hardcodees. Le composant `SocialShare.vue` est mis a jour pour utiliser `useLazyAsyncData` afin de charger les donnees de maniere non-bloquante en SSR.

## Fichiers analyses

### Fichiers crees (non commites, untracked)
- `apps/frontend/app/types/contact-link.d.ts` (57 lignes) -- Types TypeScript
- `apps/frontend/app/composables/useContactLinks.ts` (224 lignes) -- Composable API

### Fichiers modifies (staged)
- `apps/frontend/app/types/social.d.ts` -- Type `SocialPlatform` etendu avec `tiktok` et `youtube`
- `apps/frontend/app/composables/useSocialData.ts` -- Refactorise avec API + fallback
- `apps/frontend/app/components/SocialShare.vue` -- Utilise `useLazyAsyncData`
- `apps/frontend/app/composables/__tests__/useSocialData.spec.ts` -- Tests reduits aux fonctions pures

---

## Problemes critiques

### 1. Absence de sanitization des URLs provenant de l'API (XSS)

**Fichier** : `apps/frontend/app/composables/useContactLinks.ts`, ligne 82-83

Les URLs retournees par l'API sont directement injectees dans les attributs `href` des liens du template `SocialShare.vue` sans aucune validation cote frontend. Meme si le backend valide les URLs a la creation (regex `^(https?:\/\/|mailto:).+`), les donnees pourraient etre alterees en base de donnees (injection SQL, compromission admin) et le frontend doit constituer une deuxieme ligne de defense.

**Scenario de risque** : Si un attaquant compromet le backoffice ou la base de donnees et insere une URL `javascript:alert(document.cookie)`, celle-ci serait rendue directement dans un `<a href>`.

**Note attenuante** : Le DTO backend valide que les URLs commencent par `http://`, `https://`, ou `mailto:`, ce qui bloque `javascript:`. Cependant, la defense en profondeur recommande une validation cote frontend aussi.

**Solution proposee** :
```typescript
// Dans useContactLinks.ts, ajouter une validation avant d'exposer les donnees
function isValidContactUrl(url: string): boolean {
  try {
    const parsed = new URL(url)
    return ['http:', 'https:', 'mailto:'].includes(parsed.protocol)
  } catch {
    return false
  }
}

// Dans fetchContactLinks, filtrer les liens invalides
if (data && Array.isArray(data)) {
  contactLinks.value = data.filter(link => isValidContactUrl(link.url))
}
```

**Note** : La fonction `isValidSocialUrl` existante dans `useSocialData.ts` (ligne 172-179) valide deja `http:` et `https:` mais n'est pas utilisee dans la chaine de traitement des donnees API, et ne gere pas `mailto:`.

---

### 2. Duplication des constantes SOCIAL_ICONS entre useContactLinks et useSocialData

**Fichiers** :
- `apps/frontend/app/composables/useContactLinks.ts`, lignes 29-38
- `apps/frontend/app/composables/useSocialData.ts`, lignes 58-64

Le meme dictionnaire d'icones SVG est defini a deux endroits differents. Les paths SVG sont identiques pour les 5 plateformes en commun. `useContactLinks.ts` ajoute `tiktok`, `youtube`, et `website`.

**Risque** : Divergence lors de mises a jour futures. Si un path SVG est mis a jour dans un fichier et pas l'autre, les icones differeront entre le mode API et le mode fallback.

**Solution proposee** :
```typescript
// Creer un fichier partage apps/frontend/app/utils/socialIcons.ts
export const SOCIAL_ICONS: Record<string, string> = {
  instagram: 'M12 2.163c3.204...',
  facebook: 'M24 12.073c0...',
  // ... toutes les plateformes
} as const

export const PLATFORM_NAMES: Record<string, string> = {
  // ...
}
```

---

## Avertissements

### 3. Couverture de tests drastiquement reduite

**Fichier** : `apps/frontend/app/composables/__tests__/useSocialData.spec.ts`

Les tests passent de **189 lignes supprimees** a seulement **12 lignes ajoutees**. Le fichier final ne contient que 73 lignes testant uniquement les fonctions pures exportees (`isValidSocialUrl` et `getPlatformColor`). Les tests suivants ont ete supprimes sans remplacement :

- Tests de structure des `SocialLink` (validation de la forme des objets)
- Tests de tri par ordre
- Tests des liens actifs seulement
- Tests de `contactInfo` (email, label, ariaLabel)
- Tests d'integration (format API-ready, filtrage par plateforme)
- Tests de serialisation JSON

**Aucun test n'existe pour** :
- Le composable `useContactLinks` (nouveau fichier, 0 test)
- Le mecanisme de fallback dans `useSocialData`
- Les fonctions adaptateur `adaptContactLinkToSocialLink` et `adaptEmailToContactInfo`
- Le comportement en cas d'erreur API
- Le composant `SocialShare.vue` avec `useLazyAsyncData`

**Solution proposee** : Ajouter au minimum :
```typescript
// __tests__/useContactLinks.spec.ts
describe('adaptContactLinkToSocialLink', () => {
  it('should convert a ContactLink to SocialLink', () => {
    const input: ContactLink = {
      id: '123', platform: 'instagram', url: 'https://instagram.com/test',
      label: '@test', sortOrder: 1, isActive: true,
      createdAt: '2026-01-01', updatedAt: '2026-01-01'
    }
    const result = adaptContactLinkToSocialLink(input)
    expect(result.platform).toBe('instagram')
    expect(result.name).toBe('Instagram')
    expect(result.ariaLabel).toContain('Instagram')
    expect(result.iconPath).toBeTruthy()
  })
})

describe('adaptEmailToContactInfo', () => {
  it('should strip mailto: prefix', () => { /* ... */ })
  it('should use url directly when no mailto: prefix', () => { /* ... */ })
  it('should use default label when none provided', () => { /* ... */ })
})

// __tests__/useSocialData.spec.ts (ajout)
describe('fallback mechanism', () => {
  it('should return fallback links when API returns empty', () => { /* ... */ })
  it('should return fallback contact when no email link', () => { /* ... */ })
})
```

### 4. Nouvelle instance de composable a chaque appel -- pas de state sharing

**Fichier** : `apps/frontend/app/composables/useContactLinks.ts`, lignes 117-224

Chaque appel a `useContactLinks()` cree de nouvelles instances `ref()` (lignes 134-136). Contrairement aux composables Nuxt comme `useState`, les `ref()` ne sont pas partagees entre les composants. Si `useContactLinks()` est utilise dans plusieurs composants, chacun a son propre etat independant et fait sa propre requete API.

Dans le code actuel, ce n'est pas un probleme bloquant car `useSocialData` appelle `useContactLinks` une seule fois, et `SocialShare.vue` utilise `useLazyAsyncData` avec la cle `'contact-links'` pour la deduplication Nuxt. Cependant, si un autre composant appelle `useContactLinks()` directement, les donnees ne seront pas partagees.

**Reference** : Le pattern `useAboutSections.ts` a le meme comportement, donc c'est coherent avec le codebase existant. Mais pour un composable susceptible d'etre utilise a plusieurs endroits, `useState` ou un state au niveau module serait preferable.

**Solution optionnelle** :
```typescript
// Utiliser useState pour le state partage (optionnel, seulement si necessaire)
const contactLinks = useState<ContactLink[]>('contact-links-data', () => [])
const loading = useState<boolean>('contact-links-loading', () => false)
const error = useState<Error | null>('contact-links-error', () => null)
```

### 5. Console.log en production

**Fichier** : `apps/frontend/app/composables/useContactLinks.ts`, lignes 149, 156, 159, 164

Quatre appels `console.log` / `console.warn` / `console.error` sont presents dans le code. Ils polluent les logs serveur en production et exposent des details d'implementation (URL de l'API, nombre de liens).

**Note** : Ce pattern est identique a `useAboutSections.ts` et `useProducts.ts`, donc c'est coherent avec le codebase. Cependant, cela reste un avertissement general pour le projet.

**Solution** : Utiliser un logger conditionnel ou supprimer les logs de debug :
```typescript
const isDev = process.env.NODE_ENV !== 'production'
if (isDev) {
  console.log(`[useContactLinks] Fetched ${data.length} contact links`)
}
```

### 6. Le cast `as string as SocialPlatform` est une assertion de type non securisee

**Fichier** : `apps/frontend/app/composables/useContactLinks.ts`, ligne 76

```typescript
const platform = contactLink.platform as string as SocialPlatform
```

Ce double cast contourne le systeme de types TypeScript. Si l'API retourne une plateforme comme `'website'` ou `'other'` (valeurs de `ContactPlatform` mais pas de `SocialPlatform`), la valeur sera assignee comme `SocialPlatform` sans erreur de compilation, mais le type sera incorrect a l'execution.

En pratique, la fonction `adaptContactLinkToSocialLink` n'est appelee que dans `socialLinks` computed qui filtre deja par `SOCIAL_PLATFORMS` (ligne 178), donc les plateformes `email`, `website`, `other` ne passent jamais. Mais la fonction elle-meme n'est pas type-safe.

**Solution proposee** :
```typescript
function adaptContactLinkToSocialLink(contactLink: ContactLink): SocialLink {
  // ContactPlatform et SocialPlatform partagent les memes valeurs sociales
  // Ce cast est securise car cette fonction n'est appelee qu'apres filtrage
  // par SOCIAL_PLATFORMS dans le computed socialLinks
  const platform = contactLink.platform as unknown as SocialPlatform
  // ... ou mieux, utiliser une type guard :
}

// Alternative plus type-safe :
function isSocialPlatform(platform: string): platform is SocialPlatform {
  return ['instagram', 'facebook', 'twitter', 'pinterest', 'linkedin', 'tiktok', 'youtube']
    .includes(platform)
}
```

---

## Suggestions

### 7. Le fallback retourne toujours les donnees par defaut avant la premiere reponse API

**Fichier** : `apps/frontend/app/composables/useSocialData.ts`, lignes 125-133

```typescript
const socialLinks = computed<SocialLink[]>(() => {
  if (apiSocialLinks.value.length > 0) {
    return apiSocialLinks.value
  }
  return FALLBACK_SOCIAL_LINKS
})
```

Ce `computed` ne differencie pas entre "l'API n'a pas encore ete appelee" et "l'API a repondu avec 0 liens actifs". Si le backend retourne legitimement un tableau vide (tous les liens sont desactives dans le backoffice), le fallback sera toujours affiche, ce qui est peut-etre incorrect.

**Solution proposee** :
```typescript
// Ajouter un flag "fetched" dans useContactLinks
const hasFetched = ref(false)

const fetchContactLinks = async (): Promise<void> => {
  // ...
  try {
    // ...
    hasFetched.value = true
  } catch {
    hasFetched.value = true // meme en cas d'erreur, on sait qu'on a essaye
  }
}

// Dans useSocialData :
const socialLinks = computed<SocialLink[]>(() => {
  if (apiSocialLinks.value.length > 0) {
    return apiSocialLinks.value
  }
  // Utiliser le fallback seulement si on n'a pas encore fetche ou en cas d'erreur
  if (!hasFetched.value || apiError.value) {
    return FALLBACK_SOCIAL_LINKS
  }
  return [] // L'API a repondu avec 0 liens, respecter cette reponse
})
```

### 8. SOCIAL_ICONS utilise `Record<string, string>` au lieu d'un type strict

**Fichier** : `apps/frontend/app/composables/useContactLinks.ts`, ligne 29

```typescript
const SOCIAL_ICONS: Record<string, string> = { ... } as const
```

Le type `Record<string, string>` est trop permissif et le `as const` est neutralise par le typage explicite. Cela permet d'acceder a `SOCIAL_ICONS['nonexistent']` sans erreur TypeScript.

**Solution proposee** :
```typescript
const SOCIAL_ICONS = {
  instagram: '...',
  facebook: '...',
  // ...
} as const satisfies Record<string, string>

// Ou avec un type derive de ContactPlatform :
const SOCIAL_ICONS: Partial<Record<ContactPlatform, string>> = { ... }
```

### 9. La fonction `getLinkByPlatform` retournee par useContactLinks n'est pas reactive

**Fichier** : `apps/frontend/app/composables/useContactLinks.ts`, lignes 205-207

```typescript
const getLinkByPlatform = (platform: ContactPlatform): ContactLink | null => {
  return contactLinks.value.find(link => link.platform === platform) ?? null
}
```

Cette fonction retourne une valeur brute, pas un `computed`. Si `contactLinks` est mis a jour apres l'appel a `getLinkByPlatform`, la valeur retournee ne sera pas mise a jour dans le template. C'est acceptable si on l'utilise dans un handler, mais potentiellement confus si on l'utilise dans un template.

**Suggestion** : Documenter que cette methode n'est pas reactive, ou la transformer en factory de computed :
```typescript
const getLinkByPlatform = (platform: ContactPlatform): ComputedRef<ContactLink | null> => {
  return computed(() =>
    contactLinks.value.find(link => link.platform === platform) ?? null
  )
}
```

### 10. L'import `SocialShareConfig` supprime de `social.d.ts` reste dans le type

**Fichier** : `apps/frontend/app/types/social.d.ts`, lignes 92-110

L'interface `SocialShareConfig` est toujours definie dans le fichier de types, mais l'import a ete retire de `useSocialData.ts` et de `SocialShare.vue`. Ce type n'est plus utilise nulle part dans le codebase modifie. C'est du code mort.

**Solution** : Verifier les usages restants de `SocialShareConfig` dans le projet et le supprimer s'il n'est plus utilise.

### 11. Les fichiers nouveaux ne sont pas commites

**Fichiers** :
- `apps/frontend/app/composables/useContactLinks.ts` (status: `??` untracked)
- `apps/frontend/app/types/contact-link.d.ts` (status: `??` untracked)

Les fichiers modifies (`SocialShare.vue`, `useSocialData.ts`, `social.d.ts`, test) sont staged dans le commit `cecdc50d`, mais les deux nouveaux fichiers sont untracked. Le code compile probablement grace a l'auto-import Nuxt, mais les fichiers doivent etre commites pour que l'integration fonctionne.

### 12. Le handler `handleSocialClick` est inutilise fonctionnellement

**Fichier** : `apps/frontend/app/components/SocialShare.vue`, lignes 81-87

```typescript
const handleSocialClick = (platform: string, url: string): void => {
  // Future enhancement: Track analytics
  // Link navigation is handled by the anchor tag
}
```

Ce handler ne fait rien. Il est attache via `@click` sur les liens (ligne 123) mais le corps est vide. Cela ajoute un event listener inutile a chaque lien social. Idem pour `handleEmailClick` (lignes 93-96).

**Suggestion** : Supprimer les handlers vides et les `@click` associes, ou les implementer. Les re-ajouter quand l'analytics sera effectivement integree.

---

## Points positifs

1. **Architecture solide** : La separation en trois couches (types, composable API, composable facade, composant) est bien pensee et coherente avec les patterns existants (`useProducts`, `useAboutSections`).

2. **Fallback resilient** : Le mecanisme de fallback dans `useSocialData` garantit que le composant affiche toujours des donnees, meme si l'API est indisponible. C'est une excellente pratique pour un composant present sur toutes les pages.

3. **Coherence avec le codebase** : Le composable `useContactLinks` suit exactement le meme pattern que `useAboutSections` (getApiUrl, $fetch, timeout, loading/error states, readonly). Cela facilite la maintenance.

4. **Utilisation de `useLazyAsyncData`** : Le choix de `useLazyAsyncData` au lieu de `useAsyncData` dans `SocialShare.vue` est pertinent car il permet un rendu non-bloquant. Le composant s'affiche immediatement avec les donnees de fallback puis se met a jour quand l'API repond.

5. **Accessibilite** : Les `ariaLabel` sont generes de maniere coherente, les SVG ont `aria-hidden="true"`, et le composant offre des focus indicators et une navigation clavier.

6. **Pattern Adapter bien implemente** : Les fonctions `adaptContactLinkToSocialLink` et `adaptEmailToContactInfo` convertissent proprement les entites backend en interfaces frontend, isolant les composants des details de l'API.

7. **Typage TypeScript aligne** : Le type `ContactPlatform` dans `contact-link.d.ts` est parfaitement aligne avec l'enum backend `ContactPlatform`, et `SocialPlatform` a ete correctement etendu avec `tiktok` et `youtube`.

8. **Readonly state** : L'utilisation de `readonly()` pour exposer l'etat dans `useContactLinks` empeche les mutations accidentelles depuis les composants consommateurs.

9. **Deduplication Nuxt** : La cle `'contact-links'` dans `useLazyAsyncData` avec `dedupe: 'defer'` evite les appels API redondants si le composant est monte plusieurs fois.

10. **Documentation JSDoc** : Chaque fonction, constante et computed est documente avec des commentaires JSDoc incluant les patterns utilises. La documentation est complete et coherente.

---

## Statistiques
- Fichiers crees : 2
- Fichiers modifies : 4
- Lignes ajoutees : +134
- Lignes supprimees : -262
- Score de qualite : 7/10

**Justification du score** :
- -1 : Absence de validation frontend des URLs API (securite)
- -1 : Couverture de tests drastiquement reduite sans plan de remplacement
- -0.5 : Duplication des constantes SOCIAL_ICONS
- -0.5 : Fichiers nouveaux non commites

## References
- Commit principal : `cecdc50d` (fichiers modifies)
- Commit precedent : `3b74834e`
- Branche : `main`
- Fichiers de reference : `useAboutSections.ts`, `useProducts.ts`
- Backend entity : `apps/backend/src/entities/contact-link.entity.ts`
- Backend DTO : `apps/backend/src/modules/contact-links/dto/create-contact-link.dto.ts`
