# Code Review - 2026-02-07 10:00:00

## Resume

Revue de code du module "Contact & Social Links" du backoffice. Ce module comprend 4 fichiers non commites ajoutant la gestion CRUD des liens de contact et reseaux sociaux, ainsi qu'une modification de la navigation. L'implementation suit le modele etabli par le module AboutSections existant.

## Fichiers analyses

| Fichier | Statut | Lignes |
|---------|--------|--------|
| `apps/backoffice/app/types/contact-link.d.ts` | Nouveau (untracked) | 65 |
| `apps/backoffice/app/composables/useContactLinks.ts` | Nouveau (untracked) | 290 |
| `apps/backoffice/app/components/contact-links/ContactLinkForm.vue` | Nouveau (untracked) | 435 |
| `apps/backoffice/app/pages/contact-links.vue` | Nouveau (untracked) | 385 |
| `apps/backoffice/app/composables/useNavigation.ts` | Modifie (committed) | 82 |

Fichiers de reference compares :
- `apps/backoffice/app/composables/useAboutSections.ts`
- `apps/backoffice/app/components/about-sections/AboutSectionForm.vue`
- `apps/backoffice/app/pages/about.vue`
- `apps/backend/src/entities/contact-link.entity.ts`
- `apps/backend/src/modules/contact-links/dto/create-contact-link.dto.ts`
- `apps/backend/src/modules/contact-links/contact-links.controller.ts`

---

## Problemes critiques

### C1. Shared state entre instances du composable (useContactLinks)

**Fichier** : `apps/backoffice/app/composables/useContactLinks.ts`, lignes 33-37

Le composable declare `ref()` a l'interieur de la fonction, ce qui signifie que **chaque appel a `useContactLinks()` cree une nouvelle instance d'etat independante**. Le formulaire `ContactLinkForm.vue` (ligne 43-49) et la page `contact-links.vue` (ligne 29-38) appellent chacun `useContactLinks()`, creant deux instances d'etat separees.

**Consequence** : Lorsque le formulaire appelle `createContactLink()` ou `updateContactLink()`, les mutations d'etat local (lignes 178-179, 208-214) ne sont **pas visibles** dans la page principale puisque c'est une instance differente. Cela fonctionne malgre tout car `handleFormSuccess` (page, ligne 116-120) fait un `refreshContactLinks()` apres succes, ce qui re-fetch les donnees. Mais le composable fait quand meme un travail inutile en mettant a jour un etat local jamais lu.

**Ce n'est pas un bug fonctionnel** grace au refresh, mais c'est une incoherence architecturale. Le meme pattern existe dans `useAboutSections` de reference, donc c'est un choix delibere du projet. Neanmoins, il serait plus propre de :

```typescript
// Option A : Extraire l'etat hors de la fonction pour le partager
const contactLinks = ref<ContactLink[]>([])
const loading = ref(false)
const error = ref<ApiError | null>(null)

export function useContactLinks() {
  // ...utilise le state partage
}

// Option B : Ne pas faire de mutation locale dans create/update/delete,
// puisque la page fait toujours un refresh apres
```

**Severite** : Moyenne-haute. Pas de bug visible, mais source de confusion et de bugs potentiels si un futur developpeur s'attend a ce que l'etat soit partage.

---

### C2. Faille XSS potentielle dans le rendu d'error.message

**Fichier** : `apps/backoffice/app/components/contact-links/ContactLinkForm.vue`, ligne 296
**Fichier** : `apps/backoffice/app/pages/contact-links.vue`, ligne 250

```html
<p class="text-sm">{{ error.message }}</p>
```

Le champ `error.message` provient directement de la reponse API (`err.data?.message`). Vue 3 echappe les interpolations `{{ }}` par defaut, donc il n'y a **pas de XSS ici**. Cependant, le type `ApiError.message` est defini comme `string | string[]` (ligne 26 du composable). Quand le backend renvoie un tableau de messages de validation (ce que NestJS fait par defaut avec `class-validator`), le rendu affichera quelque chose comme `"url must start with http,URL is required"` -- une concatenation brute sans formatage.

**Solution** :

```typescript
// Dans le composable, normaliser le message
message: Array.isArray(err.data?.message)
  ? err.data.message.join('. ')
  : err.data?.message || err.message || 'An error occurred',
```

**Severite** : Moyenne. Pas de faille de securite mais experience utilisateur degradee pour les erreurs de validation multiples.

---

## Avertissements

### W1. Le bouton Submit est hors du `<form>` - double soumission possible

**Fichier** : `apps/backoffice/app/components/contact-links/ContactLinkForm.vue`, lignes 308, 407-433

Le `<form>` se termine a la ligne 407 (`</form>`), mais le bouton `Submit` est dans le footer (lignes 421-430), **en dehors du form**. Le bouton utilise `@click="handleSubmit"` au lieu d'etre un vrai `type="submit"` dans le formulaire. Cela a deux consequences :

1. La soumission par la touche Enter dans un champ `<input>` declenchera `@submit.prevent="handleSubmit"` via le form, et un clic sur le bouton aussi. Pas de double soumission ici car le bouton est hors du form. Mais la touche Enter et le clic bouton prennent des chemins differents.

2. L'attribut `type="submit"` sur le bouton (ligne 422) est trompeur : il ne soumet aucun form puisqu'il est en dehors. C'est une incoherence semantique.

**Note** : Ce pattern est identique a `AboutSectionForm.vue` (meme structure). Donc c'est un choix delibere du projet, probablement impose par le layout Sheet (header / scrollable content / footer).

**Solution possible** : Utiliser l'attribut `form` du bouton pour le rattacher au formulaire :

```html
<form id="contact-link-form" @submit.prevent="handleSubmit">
  <!-- ... -->
</form>

<!-- Dans le footer -->
<Button type="submit" form="contact-link-form" :disabled="loading || showSuccess">
```

**Severite** : Faible. Fonctionne correctement grace au `@click` explicite.

### W2. Type `any` dans le catch de executeApiCall

**Fichier** : `apps/backoffice/app/composables/useContactLinks.ts`, ligne 105

```typescript
} catch (err: any) {
```

L'utilisation de `any` bypasse la verification TypeScript. C'est le meme pattern que dans `useAboutSections`, mais ce serait plus propre de typer l'erreur :

```typescript
} catch (err: unknown) {
  const error = err as { statusCode?: number; status?: number; data?: { message?: string; error?: string }; message?: string }
  // ...
}
```

**Severite** : Faible. Convention TypeScript standard, mais `unknown` est prefere pour la securite de type.

### W3. Duplication de `platformLabels` entre le formulaire et la page

**Fichier** : `apps/backoffice/app/components/contact-links/ContactLinkForm.vue`, lignes 54-65 (`platformOptions`)
**Fichier** : `apps/backoffice/app/pages/contact-links.vue`, lignes 133-144 (`platformLabels`)

Les labels de plateforme sont definis deux fois dans deux formats differents (`PlatformConfig[]` et `Record<string, string>`). Si une nouvelle plateforme est ajoutee, il faut penser a mettre a jour les deux endroits.

**Solution** : Extraire dans un fichier partage :

```typescript
// types/contact-link.d.ts ou un fichier constants
export const PLATFORM_LABELS: Record<ContactPlatform, string> = {
  email: 'Email',
  facebook: 'Facebook',
  // ...
}
```

Note : Cela ne peut pas aller dans un fichier `.d.ts` (declarations only). Creer un fichier `utils/contact-link.ts` ou `constants/contact-link.ts`.

**Severite** : Faible-Moyenne. Risque de desynchronisation.

### W4. Pas de sanitization de l'URL avant rendu en `<a href>`

**Fichier** : `apps/backoffice/app/pages/contact-links.vue`, lignes 345-352

```html
<a :href="link.url" target="_blank" rel="noopener noreferrer">
```

L'URL vient directement de la base de donnees. Bien que la validation frontend et backend imposent que l'URL commence par `http://`, `https://`, ou `mailto:`, un attaquant qui insererait directement en base une URL `javascript:` pourrait exploiter cela. Le `rel="noopener noreferrer"` est bien present, ce qui est positif.

La validation backend avec `@Matches(/^(https?:\/\/|mailto:).+/)` protege correctement contre les schemas dangereux, donc le risque reel est **faible**. Mais pour une defense en profondeur :

```typescript
const getSafeUrl = (url: string): string => {
  if (/^(https?:\/\/|mailto:)/.test(url)) return url
  return '#'
}
```

**Severite** : Faible (backend valide deja).

### W5. La validation regex du label n'accepte pas les caracteres accentues

**Fichier** : `apps/backoffice/app/components/contact-links/ContactLinkForm.vue`, ligne 130

```typescript
} else if (formData.value.label && !/^[a-zA-Z0-9@_.\-\s]*$/.test(formData.value.label)) {
```

Cette regex refuse les caracteres accentues (e, a, u, etc.), les caracteres non-latins, et d'autres caracteres courants comme `'` ou `&`. Pour un site en francais, un label comme "Page principale" passerait mais "Resume" ou "Atelier Kaisla - Decouverte" echouerait avec des accents.

**Note** : La meme regex existe dans le backend DTO (`create-contact-link.dto.ts`, ligne 50), donc le frontend est aligne avec le backend. La correction devrait etre faite des deux cotes si necessaire.

**Severite** : Faible-Moyenne. Depend de l'usage reel des labels.

### W6. Le `Select` component pourrait ne pas fonctionner avec `<option>` children

**Fichier** : `apps/backoffice/app/components/contact-links/ContactLinkForm.vue`, lignes 312-325

```html
<Select id="platform" v-model="formData.platform">
  <option v-for="option in platformOptions" :key="option.value" :value="option.value">
    {{ option.label }}
  </option>
</Select>
```

Si le composant `Select` provient d'une librairie UI comme shadcn-vue / radix-vue, il n'accepte generalement pas de `<option>` enfants natifs HTML. Ces librairies utilisent `SelectTrigger`, `SelectContent`, `SelectItem`, etc. Si le `Select` est un wrapper autour d'un `<select>` natif, alors c'est correct.

**Verification necessaire** : Le fichier `@/components/ui/select` doit etre inspecte pour confirmer le pattern attendu.

**Severite** : Moyenne. Si ce n'est pas un select natif, le dropdown pourrait ne pas fonctionner du tout.

---

## Suggestions

### S1. Extraire `getApiUrl()` et `getAuthHeaders()` dans un composable partage

Les fonctions `getApiUrl()` et `getAuthHeaders()` sont identiques entre `useContactLinks.ts` et `useAboutSections.ts`. Elles devraient etre extraites dans un composable `useApi.ts` reutilisable :

```typescript
// composables/useApi.ts
export function useApi() {
  const config = useRuntimeConfig()

  const getApiUrl = (): string => { /* ... */ }
  const getAuthHeaders = (): HeadersInit => { /* ... */ }
  const executeApiCall = async <T>(...) => { /* ... */ }

  return { getApiUrl, getAuthHeaders, executeApiCall }
}
```

Cela reduirait significativement la duplication (~90 lignes dupliquees entre les deux composables).

### S2. Extraire `truncateText()` et `formatDate()` dans des utils

**Fichiers** : `contact-links.vue` (lignes 156-170) et `about.vue` (lignes 132-146)

Ces fonctions utilitaires identiques sont dupliquees. Elles devraient aller dans un fichier `utils/format.ts` :

```typescript
export const truncateText = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) return text
  return text.substring(0, maxLength) + '...'
}

export const formatDate = (dateString: string): string => {
  return new Date(dateString).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  })
}
```

### S3. Ajouter des `aria-label` sur les boutons d'action de la liste

**Fichier** : `apps/backoffice/app/pages/contact-links.vue`, lignes 354-369

Les boutons Edit et Delete ont `title` mais pas `aria-label`. Pour l'accessibilite, ajouter des labels descriptifs :

```html
<Button
  variant="ghost"
  size="sm"
  :title="`Edit ${getPlatformLabel(link.platform)}`"
  :aria-label="`Edit ${getPlatformLabel(link.platform)} link`"
  @click="openEditForm(link)"
>
```

### S4. Ajouter une confirmation visuelle plus explicite pour la suppression

Le `confirm()` natif du navigateur (ligne 77) est fonctionnel mais ne s'integre pas au design system du backoffice. Considerer un dialogue modal composant.

### S5. Proteger la page avec un middleware d'authentification

La page `contact-links.vue` charge les donnees via `onMounted` sans verifier l'authentification. Si un utilisateur non authentifie accede a la page, la requete API echouera avec un 401 et sera redirigee vers `/login` par le composable. Cela fonctionne, mais un middleware Nuxt `definePageMeta({ middleware: 'auth' })` serait plus propre.

### S6. Ajouter l'interface `ApiError` dans un fichier de types partage

Le type `ApiError` est defini localement dans chaque composable (ligne 24-28 de `useContactLinks.ts` et `useAboutSections.ts`). Il devrait etre dans `types/api.d.ts` :

```typescript
export interface ApiError {
  statusCode: number
  message: string | string[]
  error?: string
}
```

### S7. Les `console.debug` / `console.log` devraient etre retires en production

**Fichier** : `apps/backoffice/app/composables/useContactLinks.ts`, lignes 142, 169, 196, 227

Les appels `console.debug()` sont utiles en developpement mais ne devraient pas etre en production. Utiliser un logger conditionnel ou les retirer.

---

## Points positifs

1. **Coherence architecturale excellente** : Le module contact-links suit fidelement les patterns etablis par le module about-sections, facilitant la maintenance.

2. **Validation frontend alignee avec le backend** : Les regles de validation (regex URL, regex label, longueurs max, sortOrder >= 0) sont identiques entre le frontend et le backend DTO, assurant une coherence bi-directionnelle.

3. **Gestion d'erreur 401 robuste** : La redirection automatique vers `/login` lors d'un token expire ou invalide, avec nettoyage du `localStorage`, est bien implementee.

4. **Etat readonly expose** : Le composable expose `readonly(contactLinks)`, `readonly(loading)`, `readonly(error)`, empechant les mutations accidentelles depuis les composants consommateurs.

5. **Types bien structures** : Les types `ContactLink`, `CreateContactLinkDto`, `UpdateContactLinkDto` et `PlatformConfig` sont bien definis avec les champs optionnels correctement marques.

6. **UX soignee** : Etats loading, empty et error bien geres. Message de succes avec delai, bouton Cancel desactive pendant le loading, badges visuels pour le statut actif/inactif et l'ordre de tri.

7. **Securite du lien externe** : `rel="noopener noreferrer"` present sur le lien `<a>` pour les URL externes.

8. **SEO** : `useSeoMeta()` utilise pour definir le titre et la description de la page.

9. **Watch avec `immediate: true`** : Le fix applique a `AboutSectionForm` est directement integre dans `ContactLinkForm`, montrant un apprentissage des problemes precedents.

10. **Tri reactif** : `sortedContactLinks` est un `computed`, donc le tri est recalcule automatiquement quand les donnees changent.

---

## Statistiques

- Fichiers nouveaux : 4
- Fichiers modifies : 1 (useNavigation.ts, deja commite)
- Lignes ajoutees : +1175
- Lignes supprimees : -0 (fichiers neufs)
- Problemes critiques : 0 (le C1 est architectural, pas bloquant)
- Avertissements : 6
- Suggestions : 7
- Score de qualite : **7.5/10**

Le score reflete un code bien structure et fonctionnel, mais penalise par la duplication significative (getApiUrl, getAuthHeaders, executeApiCall, platformLabels, truncateText, formatDate) et le possible probleme avec le composant Select.

## References

- Branche : `main`
- Commit de reference : `3b74834e`
- Fichiers non commites (untracked) : 4 fichiers contact-links dans `apps/backoffice/`
- Module backend associe : `apps/backend/src/modules/contact-links/`
